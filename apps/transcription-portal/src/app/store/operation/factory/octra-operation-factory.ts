import { HttpClient } from '@angular/common/http';
import { AnnotationLevelType, OSegment, OSegmentLevel, PartiturConverter } from '@octra/annotation';
import { OAudiofile } from '@octra/media';
import { stringifyQueryParams, SubscriptionManager } from '@octra/utilities';
import { FileInfo } from '@octra/web-media';
import { Observable, Subscription, throwError } from 'rxjs';
import { AppSettings } from '../../../shared/app.settings';
import { getHashString } from '../../preprocessing/preprocessing.functions';
import { StoreAudioFile, StoreFile, StoreItemTask, StoreItemTaskOptions } from '../../store-item';
import { StoreTaskOperation, StoreTaskOperationProcessingRound } from '../operation';
import { OperationFactory } from './operation-factory';
import { UploadOperationFactory } from './upload-operation-factory';
import { ASROperation } from './asr-operation-factory';
import { IDBOperation } from '../../../indexedDB';
import { convertStoreOperationToIDBOperation } from '../operation.functions';

export type OctraOperation = StoreTaskOperation<any, OctraOperation>;

export class OctraOperationFactory extends OperationFactory<OctraOperation> {
  protected readonly _description =
    'A literal transcript contains the verbatim text of a speech recording.' +
    'These transcripts are either generated by Automatic Speech Recognition or they are created manually from scratch.' +
    'The editor Octra allows you to correct or create such transcripts.';
  protected readonly _name = 'OCTRA';
  protected readonly _resultType = 'BAS Partitur Format';
  protected readonly _shortTitle = 'MT';
  protected readonly _title = 'Manual Transcription';

  create(id: number, taskID: number, rounds: StoreTaskOperationProcessingRound[]): OctraOperation {
    return {
      enabled: true,
      id,
      name: this.name,
      options: {},
      serviceProviderName: 'BAS',
      rounds,
      taskID,
    };
  }

  override applyTaskOptions(options: StoreItemTaskOptions, operation: OctraOperation) {
    // no options to apply
    return operation;
  }

  override run(
    storeItemTask: StoreItemTask,
    operation: OctraOperation,
    httpClient: HttpClient,
    subscrManager: SubscriptionManager<Subscription>,
  ): Observable<{ operation: StoreTaskOperation }> {
    return throwError(() => new Error('Not implemented'));
  }

  public async getToolURL(audioFile: StoreAudioFile, transcriptFile: StoreFile | undefined, httpClient: HttpClient): Promise<string> {
    if (audioFile?.online && audioFile?.url) {
      const serviceProvider = AppSettings.getServiceInformation('BAS')!;
      const audio_url = encodeURIComponent(audioFile.url);
      const audio_name = audioFile.name;
      let transcript: string | undefined;
      const embedded = `1`;
      const host = encodeURIComponent(serviceProvider.host);

      if (transcriptFile) {
        if (!transcriptFile.content) {
          throw new Error('Transcript file content does not exist');
        }

        const { extension } = FileInfo.extractFileName(transcriptFile.name);
        if (extension === '.par') {
          const oAudio = new OAudiofile();
          oAudio.name = audioFile.name;
          oAudio.url = audioFile.url;
          oAudio.type = audioFile.type;
          oAudio.size = audioFile.size;
          oAudio.duration = audioFile.duration;
          oAudio.sampleRate = audioFile.sampleRate;

          const importResult = new PartiturConverter().import(
            {
              name: transcriptFile.attributes?.originalFileName ?? transcriptFile.name,
              type: transcriptFile.type,
              content: transcriptFile.content,
              encoding: 'utf-8',
            },
            oAudio,
          );

          if (importResult && importResult.annotjson) {
            for (const level of importResult.annotjson.levels as OSegmentLevel<OSegment>[]) {
              if (level.type === AnnotationLevelType.SEGMENT) {
                for (let i = 0; i < level.items.length; i++) {
                  const item = level.items[i];
                  const nextItem = i < level.items.length - 1 ? level.items[i + 1] : undefined;

                  if (nextItem) {
                    const gapSamples = nextItem.sampleDur;

                    if (
                      item.getFirstLabelWithoutName('Speaker')?.value !== '' &&
                      item.getFirstLabelWithoutName('Speaker')?.value !== '<P>' &&
                      nextItem.getFirstLabelWithoutName('Speaker')?.value !== '' &&
                      nextItem.getFirstLabelWithoutName('Speaker')?.value !== '<P>'
                    ) {
                      // concat
                      item.replaceFirstLabelWithoutName('Speaker', (value) => {
                        return [value, nextItem.getFirstLabelWithoutName('Speaker')?.value].filter((a) => a !== undefined && a !== '').join(' ');
                      });
                      item.sampleDur += gapSamples;
                      level.items.splice(i + 1, 1);
                      i--;
                    }
                  }
                }
              }
            }

            const result = new PartiturConverter().export(importResult.annotjson, oAudio);
            if (result?.file) {
              const newFile = new File([result.file.content], result.file.name, { type: result.file.type });
              transcript = await this.upload(
                {
                  name: newFile.name,
                  type: newFile.type,
                  size: newFile.size,
                  blob: newFile,
                  attributes: {
                    originalFileName: newFile.name,
                  },
                  hash: await getHashString(newFile),
                },
                httpClient,
              );
            }
          }
        }

        if (!transcript) {
          transcript = transcriptFile.url;
        }
      }

      return `${this.commands[0]}/${stringifyQueryParams({
        audio_url,
        audio_name,
        transcript,
        host,
        embedded,
      })}`;
    }
    return '';
  }

  private upload(file: StoreFile, httpClient: HttpClient): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      const subj = UploadOperationFactory.upload([file], httpClient);
      subj.subscribe({
        next: (obj) => {
          if (obj.type === 'loadend') {
            // add messages to protocol
            if (obj.warnings) {
              console.warn(obj.warnings);
            }
            resolve(obj.urls![0]);
          }
        },
        error: (err) => {
          reject(err);
        },
      });
    });
  }

  override async convertOperationToIDBOperation(operation:OctraOperation):Promise<IDBOperation> {
    return await convertStoreOperationToIDBOperation(operation);
  }
}
