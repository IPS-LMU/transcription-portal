import { HttpClient } from '@angular/common/http';
import { DomSanitizer } from '@angular/platform-browser';
import { AnnotationLevelType, OSegment, OSegmentLevel, PartiturConverter } from '@octra/annotation';
import { ServiceProvider } from '@octra/ngx-components';
import { stringifyQueryParams } from '@octra/utilities';
import { AudioInfo, FileInfo, readFileContents } from '@octra/web-media';
import { AppSettings } from '../../shared/app.settings';
import { Task, TaskStatus } from '../tasks';
import { IOperation, Operation, OperationOptions } from './operation';
import { ToolOperation } from './tool-operation';
import { UploadOperation } from './upload-operation';

export type IOctraOperation = IOperation;

export class OCTRAOperation extends ToolOperation {
  public constructor(
    name: string,
    commands: string[],
    title?: string,
    shortTitle?: string,
    task?: Task,
    state?: TaskStatus,
    id?: number,
    serviceProvider?: ServiceProvider,
  ) {
    super(name, commands, title, shortTitle, task, state, id, serviceProvider);
    this._description =
      'A literal transcript contains the verbatim text of a speech recording.' +
      'These transcripts are either generated by Automatic Speech Recognition or they are created manually from scratch.' +
      'The editor Octra allows you to correct or create such transcripts.';
  }

  public override resultType = 'BAS Partitur Format';

  protected operations: Operation[] | undefined;

  public override start = async (inputs: FileInfo[], operations: Operation[], httpclient: HttpClient, accessCode?: string) => {
    this.updateProtocol('');
    this.operations = operations;
    this.changeState(TaskStatus.READY);
  };

  public override getStateIcon = (sanitizer: DomSanitizer) => {
    let result = '';

    switch (this.state) {
      case TaskStatus.PENDING:
        result = ``;
        break;
      case TaskStatus.UPLOADING:
        result = `<div class="spinner-border spinner-border-small" role="status">
  <span class="visually-hidden">Loading...</span>
</div>`;
        break;
      case TaskStatus.PROCESSING:
        result = '<i class="bi bi-gear-fill spin link" aria-hidden="true"></i>';
        break;
      case TaskStatus.FINISHED:
        result = '<i class="bi bi-check-lg" aria-hidden="true"></i>';
        break;
      case TaskStatus.READY:
        result = '<i class="bi bi-pencil-square link" aria-hidden="true"></i>';
        break;
      case TaskStatus.ERROR:
        result = '<i class="bi bi-x-lg" aria-hidden="true"></i>';
        break;
    }

    return sanitizer.bypassSecurityTrustHtml(result);
  };

  public override getStateIcon2 = () => {
    let result = '';

    switch (this.state) {
      case TaskStatus.PENDING:
        result = ``;
        break;
      case TaskStatus.UPLOADING:
        result = `<div class="spinner-border spinner-border-small" role="status">
  <span class="visually-hidden">Loading...</span>
</div>`;
        break;
      case TaskStatus.PROCESSING:
        result = '<i class="bi bi-gear-fill spin link" aria-hidden="true"></i>';
        break;
      case TaskStatus.FINISHED:
        result = '<i class="bi bi-check-lg" aria-hidden="true"></i>';
        break;
      case TaskStatus.READY:
        result = '<i class="bi bi-pencil-square link" aria-hidden="true"></i>';
        break;
      case TaskStatus.ERROR:
        result = '<i class="bi bi-x-lg" aria-hidden="true"></i>';
        break;
    }

    return result;
  };

  public override clone(task?: Task): OCTRAOperation {
    const selectedTask = task === null || task === undefined ? this.task : task;
    return new OCTRAOperation(this.name, this._commands, this.title, this.shortTitle, selectedTask, this.state, undefined, this.serviceProvider);
  }

  public override fromAny(operationObj: IOctraOperation, commands: string[], task: Task): OCTRAOperation {
    const result = new OCTRAOperation(
      operationObj.name,
      commands,
      this.title,
      this.shortTitle,
      task,
      operationObj.state,
      operationObj.id,
      AppSettings.getServiceInformation(operationObj.serviceProvider),
    );

    for (const resultObj of operationObj.results) {
      const resultClass = FileInfo.fromAny(resultObj);
      resultClass.attributes = resultObj.attributes;
      result.results.push(resultClass);
    }

    result._time = operationObj.time;
    result.updateProtocol(operationObj.protocol);
    result.enabled = operationObj.enabled;

    if (result.state === TaskStatus.PROCESSING) {
      if (result.results.length > 0) {
        result.changeState(TaskStatus.FINISHED);
      } else {
        result.changeState(TaskStatus.READY);
      }
    }

    return result;
  }

  public override async getToolURL(httpClient: HttpClient): Promise<string> {
    if (
      this.operations &&
      !(
        (this.operations[0] as unknown as UploadOperation).wavFile === null ||
        (this.operations[0] as unknown as UploadOperation).wavFile === undefined
      ) &&
      this.task
    ) {
      const serviceProvider = AppSettings.getServiceInformation('BAS')!;
      const audio_url = encodeURIComponent((this.operations[0] as any)?.wavFile?.url) as string;
      const audio_name = (this.operations[0] as unknown as UploadOperation)?.wavFile?.fullname;
      let transcript: string | undefined;
      const embedded = `1`;
      const host = encodeURIComponent(serviceProvider.host);

      let transcriptFile: FileInfo | undefined = undefined;

      if (this.results.length < 1 && this.previousOperation) {
        // no results, but previousOperation exists
        if (this.previousOperation.results.length > 0 && this.previousOperation.lastResult) {
          transcriptFile = this.previousOperation.lastResult;
        } else if (
          this.previousOperation.previousOperation &&
          this.previousOperation.previousOperation.lastResult &&
          this.previousOperation.previousOperation.results.length > 1
        ) {
          transcriptFile = this.previousOperation.previousOperation.lastResult;
        }
      } else if (this.lastResult) {
        transcriptFile = this.lastResult;
      }

      if (transcriptFile && transcriptFile?.file) {
        if (transcriptFile.extension === '.par') {
          const task = this.task;
          const auiofile = task.files.find((a) => a.type.includes('audio')) as AudioInfo;
          const content = await readFileContents<string>(transcriptFile.file, 'text', 'utf-8');
          const importResult = new PartiturConverter().import(
            {
              name: transcriptFile.attributes?.originalFileName ?? transcriptFile.fullname,
              type: transcriptFile.type,
              content,
              encoding: 'utf-8',
            },
            auiofile,
          );
          if (importResult && importResult.annotjson) {
            for (const level of importResult.annotjson.levels as OSegmentLevel<OSegment>[]) {
              if (level.type === AnnotationLevelType.SEGMENT) {
                for (let i = 0; i < level.items.length; i++) {
                  const item = level.items[i];
                  const nextItem = i < level.items.length - 1 ? level.items[i + 1] : undefined;

                  if (nextItem) {
                    const gapSamples = nextItem.sampleDur;

                    if (item.getFirstLabelWithoutName('Speaker')?.value !== '' && nextItem.getFirstLabelWithoutName('Speaker')?.value !== '') {
                      // concat
                      item.replaceFirstLabelWithoutName('Speaker', (value) => {
                        return [value, nextItem.getFirstLabelWithoutName('Speaker')?.value].filter((a) => a !== undefined && a !== '').join(' ');
                      });
                      item.sampleDur += gapSamples;
                      level.items.splice(i + 1, 1);
                      i--;
                    }
                  }
                }
              }
            }

            const result = new PartiturConverter().export(importResult.annotjson, auiofile);
            if (result?.file) {
              const newFile = new File([result.file.content], result.file.name, { type: result.file.type });
              transcript = await this.upload(new FileInfo(newFile.name, newFile.type, newFile.size, newFile), httpClient);
            }
          }
        }

        if (!transcript) {
          transcript = transcriptFile.url;
        }
      }

      return `${this._commands[0]}/${stringifyQueryParams({
        audio_url,
        audio_name,
        transcript,
        host,
        embedded,
      })}`;
    }
    return '';
  }

  private upload(file: FileInfo, httpClient: HttpClient): Promise<string> {
    return new Promise<string>((resolve, reject) => {
      const serviceProvider = AppSettings.getServiceInformation('BAS')!;
      const url = `${serviceProvider.host}uploadFileMulti`;
      const subj = UploadOperation.upload([file], url, httpClient);
      subj.subscribe({
        next: (obj) => {
          if (obj.type === 'loadend') {
            // add messages to protocol
            if (obj.warnings) {
              console.warn(obj.warnings);
            }
            resolve(obj.urls![0]);
          }
        },
        error: (err) => {
          reject(err);
        },
      });
    });
  }

  override overwriteOptions(options: OperationOptions) {
    this._serviceProvider = AppSettings.getServiceInformation('BAS');
  }

  override async toAny(): Promise<IOctraOperation> {
    return {
      id: this.id,
      name: this.name,
      state: this.state,
      protocol: this.protocol,
      time: this.time,
      enabled: this.enabled,
      results: await this.serializeResults(),
      serviceProvider: this.serviceProvider?.provider,
    };
  }
}
